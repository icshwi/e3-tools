#!/usr/bin/env bash
#
#  Copyright (c) 2018 - 2019    Jeong Han Lee
#  Copyright (c) 2018 - 2019    European Spallation Source ERIC
#
#  The program is free software: you can redistribute
#  it and/or modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation, either version 2 of the
#  License, or any newer version.
#
#  This program is distributed in the hope that it will be useful, but WITHOUT
#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
#  more details.
#
#  You should have received a copy of the GNU General Public License along with
#  this program. If not, see https://www.gnu.org/licenses/gpl-2.0.txt
#
#
#   author  : Jeong Han Lee
#   email   : jeonghan.lee@gmail.com
#   date    : Sunday, October 27 23:23:35 CET 2019
#   version : 1.0.3


EXIST=1
NON_EXIST=0


function pushd { builtin pushd "$@" > /dev/null; }
function popd  { builtin popd  "$@" > /dev/null; }


function die
{
    error=${1:-1}
    ## exits with 1 if error number not given
    shift
    [ -n "$*" ] &&
	printf "%s%s: %s\n" "$scriptname" ${version:+" ($version)"} "$*" >&2
    exit "$error"
}


## if [[ $(checkIfDir "${rep}") -eq "$EXIST" ]]; then
##    EXIST
## fi
##

function checkIfDir
{
    
    local dir=$1
    local result=""
    if [ ! -d "$dir" ]; then
	result=$NON_EXIST
	# doesn't exist
    else
	result=$EXIST
	# exist
    fi
    echo "${result}"
};


## if [[ $(checkIfFile "${release_file}") -eq "$NON_EXIST" ]]; then
#   NON_EXIT
## fi

function checkIfFile
{
    local file=$1
    local result=""
    if [ ! -e "$file" ]; then
	result=$NON_EXIST
	# doesn't exist
    else
	result=$EXIST
	# exist
    fi
    echo "${result}"	 
};


function checkIfVar()
{

    local var=$1
    local result=""
    if [ -z "$var" ]; then
	result=$NON_EXIST
	# doesn't exist
    else
	result=$EXIST
	# exist
    fi
    echo "${result}"
}

# Usage :
# e3_version="$(read_file_get_string  "${file_name}" "E3_VERSION:=")";
# It ignores the # character
# 
function read_file_get_string
{
    local FILENAME="$1"
    local PREFIX="$2"

    local val=""
    while IFS= read -r line; do
	if [ "$line" ]; then
	    [[ "$line" =~ ^#.*$ ]] && continue
	    if [[ "$line" =~ "${PREFIX}" ]] ; then
	     	val=${line#"${PREFIX}"}
	    fi
	fi
    done < ${FILENAME}
    echo "${val// }"

}



function read_version
{
    local version="";
    local input_file=$1; shift;
    local compare_string="$1"; shift;

    #   echo "Input File     : ${input_file}"
    #   echo "Compare String : ${compare_string}"
    version="$(read_file_get_string "${input_file}" "${compare_string}:=")";
    if [ -z "${version}" ]; then
       	version="$(read_file_get_string "${input_file}" "${compare_string}=")";
    	if [ -z "${version}" ]; then
       	    version=""
       	fi
    fi
    echo "${version}"
}

function yes_or_no_to_go
{

    printf  "  You should aware what you are doing now ....\n";
    printf  "  If you are not sure, please stop this procedure immediately!\n";

    printf  "\n";
    read -p ">> Do you want to continue (y/N)? " answer
    case ${answer:0:1} in
	y|Y )
	    printf "\n"
	    ;;
	* )
            printf ">> Stop here. \n";
	    exit;
	    ;;
    esac

}


function yes_or_no_to_go_args
{

    local command="$1"
    printf  "  You should aware what you are doing now ....\n";
    printf  "  If you are not sure, please stop this procedure immediately!\n";

    printf  "\n";
    read -p ">> Do you want to continue (y/N)? " answer
    case ${answer:0:1} in
	y|Y )
	    printf "\n"
	    ;;
	* )
            printf ">> Skip here. \n";
	    $command
	    ;;
    esac

}


function git_clone
{
    local rep_name=$1
    git clone ${GIT_URL}/$rep_name
}




###
### e3 Specific Functions
###

# In order to execute this function correctly,
# git init first to be executed if the directory
# is not git repo
# [submodule "E3_MODULE_SRC_PATH"]
#      path = E3_MODULE_SRC_PATH
#      url  = url/E3_MODULE_SRC_PATH
# 
function add_submodule
{
    local rep_url=${1}
    local env_mod_name=${2}
    printf "${rep_url} is adding as submodule...\n";
    git submodule add ${rep_url}  ||  die 1 "We cannot add ${rep_url} as submodule : Please check it" ;
    printf "add ignore = dirty ... \n"
    sed -i~ "/\\/${env_mod_name}/a\\\tignore = dirty" .gitmodules  ||  die 1 "We cannot add ignore = dirty into .gitmodules : Please check it" ;
    printf "\n";
    git submodule update --init --recursive  ||  die 1 "We cannot init the gitsubmodule : Please check it" ;
}  


##
## The following functions are used to update the existent OLD e3-module based on require 3.0.0
##
function read_config_module
{
    local FILENAME="$1"
    local PREFIX1="-include \$(TOP)/configure/CONFIG_MODULE"
    local PREFIX2="-include \$(TOP)/configure/CONFIG_OPTIONS"
    local val=""
    while IFS= read -r line; do
	if [ "$line" ]; then
	    [[ "$line" =~ ^#.*$ ]] && continue
	    if [[ "$line" =~ "${PREFIX1}" ]] ; then
		echo "-include \$(TOP)/configure/CONFIG_OPTIONS"
		echo "# The definitions shown below can also be placed in an untracked CONFIG_MODULE*.local"
		echo "${line}";
		echo "#";
	    elif [[ "$line" =~ "${PREFIX2}" ]]; then
		printf "";
	    else
		echo ${line}
		echo "#"
	    fi
	fi
    done < ${FILENAME}

}

