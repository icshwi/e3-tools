#!/bin/bash
#
#  Copyright (c) 2018 - Present Jeong Han Lee
#  Copyright (c) 2018 - Present European Spallation Source ERIC
#
#  The program is free software: you can redistribute
#  it and/or modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation, either version 2 of the
#  License, or any newer version.
#
#  This program is distributed in the hope that it will be useful, but WITHOUT
#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
#  more details.
#
#  You should have received a copy of the GNU General Public License along with
#  this program. If not, see https://www.gnu.org/licenses/gpl-2.0.txt
#
#
#   author  : Jeong Han Lee
#   email   : jeonghan.lee@gmail.com
#   date    : Saturday, January 12 01:43:53 CET 2019
#   version : 0.1.4


EXIST=1
NON_EXIST=0

function pushd { builtin pushd "$@" > /dev/null; }
function popd  { builtin popd  "$@" > /dev/null; }



function die
{
    error=${1:-1}
    ## exits with 1 if error number not given
    shift
    [ -n "$*" ] &&
	printf "%s%s: %s\n" "$scriptname" ${version:+" ($version)"} "$*" >&2
    exit "$error"
}


## if [[ $(checkIfDir "${rep}") -eq "$EXIST" ]]; then
##    EXIST
## fi
##

function checkIfDir
{
    
    local dir=$1
    local result=""
    if [ ! -d "$dir" ]; then
	result=$NON_EXIST
	# doesn't exist
    else
	result=$EXIST
	# exist
    fi
    echo "${result}"
};


## if [[ $(checkIfFile "${release_file}") -eq "$NON_EXIST" ]]; then
#   NON_EXIT
## fi

function checkIfFile
{
    local file=$1
    local result=""
    if [ ! -e "$file" ]; then
	result=$NON_EXIST
	# doesn't exist
    else
	result=$EXIST
	# exist
    fi
    echo "${result}"	 
};


function checkIfVar()
{

    local var=$1
    local result=""
    if [ -z "$var" ]; then
	result=$NON_EXIST
	# doesn't exist
    else
	result=$EXIST
	# exist
    fi
    echo "${result}"
}

# Usage :
# e3_version="$(read_file_get_string  "${file_name}" "E3_VERSION:=")";
# It ignores the # character
# 
function read_file_get_string
{
    local FILENAME="$1"
    local PREFIX="$2"

    local val=""
    while IFS= read -r line; do
	if [ "$line" ]; then
	    [[ "$line" =~ ^#.*$ ]] && continue
	    if [[ "$line" =~ "${PREFIX}" ]] ; then
	     	val=${line#"${PREFIX}"}
	    fi
	fi
    done < ${FILENAME}
    echo "${val// }"

}



function read_version
{
    local version="";
    local input_file=$1; shift;
    local compare_string="$1"; shift;

    #   echo "Input File     : ${input_file}"
    #   echo "Compare String : ${compare_string}"
    version="$(read_file_get_string "${input_file}" "${compare_string}:=")";
    if [ -z "${version}" ]; then
       	version="$(read_file_get_string "${input_file}" "${compare_string}=")";
    	if [ -z "${version}" ]; then
       	    version=""
       	fi
    fi
    echo "${version}"
}

function read_config_module
{
    local FILENAME="$1"
    local PREFIX1="-include \$(TOP)/configure/CONFIG_MODULE"
    local PREFIX2="-include \$(TOP)/configure/CONFIG_OPTIONS"
    local val=""
    while IFS= read -r line; do
	if [ "$line" ]; then
	    [[ "$line" =~ ^#.*$ ]] && continue
	    if [[ "$line" =~ "${PREFIX1}" ]] ; then
		echo "-include \$(TOP)/configure/CONFIG_OPTIONS"
		echo "# The definitions shown below can also be placed in an untracked CONFIG_MODULE*.local"
		echo "${line}";
		echo "#";
	    elif [[ "$line" =~ "${PREFIX2}" ]]; then
		printf "";
	    else
		echo ${line}
		echo "#"
	    fi
	fi
    done < ${FILENAME}

}


function yes_or_no_to_go
{

    printf  "  You should aware what you are doing now ....\n";
    printf  "  If you are not sure, please stop this procedure immediately!\n";

    printf  "\n";
    read -p ">> Do you want to continue (y/N)? " answer
    case ${answer:0:1} in
	y|Y )
	    printf "\n"
	    ;;
	* )
            printf ">> Stop here. \n";
	    exit;
	    ;;
    esac

}


function git_clone
{
    local rep_name=$1
    git clone ${GIT_URL}/$rep_name
}


# In order to execute this function correctly,
# git init first to be executed if the directory
# is not git repo
# [submodule "E3_MODULE_SRC_PATH"]
#      path = E3_MODULE_SRC_PATH
#      url  = url/E3_MODULE_SRC_PATH
# 
function add_submodule
{
    local rep_url=${1}
    local env_mod_name=${2}
    printf "${rep_url} is adding as submodule...\n";
    git submodule add ${rep_url};
    printf "add ignore = dirty ... \n"
    sed -i~ "/\\/${env_mod_name}/a\\\tignore = all" .gitmodules
    printf "\n";
    git submodule update --init --recursive
}  



function add_gitignore
{
    cat > .gitignore <<EOF
*~  
*-dev
modules.order
Module.symvers
Mkfile.old
core.*
#*
.#*
\#*
*.local
\#*
.cvsignore
*_old/
*PVs.list
*-loc/*.Makefile
EOF
}


function add_readme_siteMods
{
    cat > README.md <<EOF

${_E3_MOD_NAME}  
======
ESS Site-specific EPICS module : ${_EPICS_MODULE_NAME}

EOF

}

function add_readme_siteApps
{
    cat > README.md <<EOF

${_E3_MOD_NAME}  
======
ESS Site-specific EPICS IOC Application : ${_EPICS_MODULE_NAME}

EOF

}



function add_e3_makefile
{
    cat > Makefile <<EOF
#
#  Copyright (c) 2018 - Present  European Spallation Source ERIC
#
#  The program is free software: you can redistribute
#  it and/or modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation, either version 2 of the
#  License, or any newer version.
#
#  This program is distributed in the hope that it will be useful, but WITHOUT
#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
#  more details.
#
#  You should have received a copy of the GNU General Public License along with
#  this program. If not, see https://www.gnu.org/licenses/gpl-2.0.txt
#
# 
# Author  : Jeong Han Lee
# email   : jeonghan.lee@gmail.com
# Date    : ${SC_LOGDATE}
# version : 0.0.1

TOP:=\$(CURDIR)

include \$(TOP)/configure/CONFIG

include \$(TOP)/configure/RULES

EOF
    
}


function addExampleSrc
{
    local DEST=${1}
    cat > ${DEST}/sncExample.stt <<"EOF"
program sncExample
double v;
assign v to "{user}:aiExample";
monitor v;

ss ss1 {
    state init {
        when (delay(10)) {
            printf("sncExample: Startup delay over\n");
        } state low
    }
    state low {
        when (v > 5.0) {
            printf("sncExample: Changing to high\n");
        } state high
    }
    state high {
        when (v <= 5.0) {
            printf("sncExample: Changing to low\n");
        } state low
    }
}

EOF
    cat > ${DEST}/sncExample.dbd <<"EOF"
registrar(sncExampleRegistrar)
EOF


    cat > ${DEST}/dbSubExample.c <<"EOF"
#include <stdio.h>

#include <dbDefs.h>
#include <registryFunction.h>
#include <subRecord.h>
#include <aSubRecord.h>
#include <epicsExport.h>

int mySubDebug;

static long mySubInit(subRecord *precord)
{
    if (mySubDebug)
        printf("Record %s called mySubInit(%p)\n",
               precord->name, (void*) precord);
    return 0;
}

static long mySubProcess(subRecord *precord)
{
    if (mySubDebug)
        printf("Record %s called mySubProcess(%p)\n",
               precord->name, (void*) precord);
    return 0;
}

static long myAsubInit(aSubRecord *precord)
{
    if (mySubDebug)
        printf("Record %s called myAsubInit(%p)\n",
               precord->name, (void*) precord);
    return 0;
}

static long myAsubProcess(aSubRecord *precord)
{
    if (mySubDebug)
        printf("Record %s called myAsubProcess(%p)\n",
               precord->name, (void*) precord);
    return 0;
}

/* Register these symbols for use by IOC code: */

epicsExportAddress(int, mySubDebug);
epicsRegisterFunction(mySubInit);
epicsRegisterFunction(mySubProcess);
epicsRegisterFunction(myAsubInit);
epicsRegisterFunction(myAsubProcess);

EOF

    cat > ${DEST}/dbSubExample.dbd <<"EOF"
variable(mySubDebug)
function(mySubInit)
function(mySubProcess)
function(myAsubInit)
function(myAsubProcess)

EOF
    
    cat > ${DEST}/myexampleHello.c <<"EOF"
/* Example showing how to register a new command with iocsh */

#include <stdio.h>

#include <epicsExport.h>
#include <iocsh.h>

/* This is the command, which the vxWorks shell will call directly */
void hello(const char *name) {
    if (name) {
        printf("Hello %s, from myexample\n", name);
    } else {
        puts("Hello from myexample");
    }
}

/* Information needed by iocsh */
static const iocshArg     helloArg0 = {"name", iocshArgString};
static const iocshArg    *helloArgs[] = {&helloArg0};
static const iocshFuncDef helloFuncDef = {"hello", 1, helloArgs};

/* Wrapper called by iocsh, selects the argument types that hello needs */
static void helloCallFunc(const iocshArgBuf *args) {
    hello(args[0].sval);
}

/* Registration routine, runs at startup */
static void helloRegister(void) {
    iocshRegister(&helloFuncDef, helloCallFunc);
}
epicsExportRegistrar(helloRegister);

EOF

 cat > ${DEST}/myexampleHello.dbd <<"EOF"
registrar(helloRegister)
EOF
    
    
}

function addExampleCmds
{
    local DEST=${1}
    cat > ${DEST}/example.cmd <<EOF
#var requireDebug 1
require sequencer,2.1.21
require ${_EPICS_MODULE_NAME},master
#require iocStats,ae5d083
#require recsync,1.3.0
#require autosave,5.9.0
#require MCoreUtils,1.2.1


epicsEnvSet(TOP, "\$(E3_CMD_TOP)")
epicsEnvSet("IOCNAME", "example")

dbLoadRecords("dbExample1.db" "user=\$(IOCNAME)")
dbLoadRecords("dbExample2.db" "user=\$(IOCNAME), no=1, scan=1 second")
dbLoadRecords("dbExample2.db" "user=\$(IOCNAME), no=2, scan=2 second")
dbLoadRecords("dbExample2.db" "user=\$(IOCNAME), no=3, scan=5 second")

dbLoadRecords("dbSubExample.db", "user=\$(IOCNAME)")

# need to define IOCNAME
# PV names
#loadIocsh("iocStats.iocsh", "IOCNAME=\$(IOCNAME)")
#loadIocsh("recsync.iocsh",  "IOCNAME=\$(IOCNAME)")
#loadIocsh("autosave.iocsh", "IOCNAME=\$(IOCNAME), AS_TOP=\$(TOP)")


iocInit()

## Start any sequence programs
seq sncExample, "user=\$(IOCNAME)"

EOF
}

function addExampleDb
{
    local DEST=${1}
 #    cat > ${DEST}/circle.db <<"EOF"

# record(ao, "$(user):circle:step") {
#   field(VAL , "1.0")
#   field(DRVL, "0.0")
#   field(DRVH, "359")
#   field(PINI, "YES")
# }

# record(ao, "$(user):circle:period") {
#   field(VAL , "1.0")
#   field(PINI, "YES")
#   field(OUT , "$(user):circle:tick.ODLY NPP")
# }

# record(calc, "$(user):circle:angle") {
#   field(PINI, "RUNNING") # bootstrap
#   field(INPA, "$(user):circle:angle NPP")
#   field(INPB, "$(user):circle:step NPP")
#   field(INPD, "360")
#   field(DESC, "Angle")
#   field(EGU , "deg")
#   field(LOLO, "45")
#   field(LOW , "135")
#   field(HIGH, "225")
#   field(HIHI, "315")
#   field(LLSV, "MAJOR")
#   field(LSV , "MINOR")
#   field(HSV , "MINOR")
#   field(HHSV, "MAJOR")
#   field(CALC, "C:=A+B;(C>=D)?C-D:C")
#   field(FLNK, "$(user):circle:x")
#   field(PREC, "3")
#   info(Q:group, {
#       "$(user):circle":{"angle": {+channel:"VAL"}},
#       "$(user):line":{"a": {+channel:"VAL"}}
#   })
#   alias("$(user):line:a")
# }

# record(calc, "$(user):circle:x") {
#   field(INPA, "$(user):circle:angle NPP")
#   field(CALC, "cos(A*PI/180)")
#   field(TSEL, "$(user):circle:angle.TIME")
#   field(FLNK, "$(user):circle:y")
#   field(PREC, "3")
#   info(Q:group, {
#       "$(user):circle":{"x": {+channel:"VAL"}}
#   })
# }

# record(calc, "$(user):circle:y") {
#   field(INPA, "$(user):circle:angle NPP")
#   field(CALC, "sin(A*PI/180)")
#   field(TSEL, "$(user):circle:angle.TIME")
#   field(PREC, "3")
#   field(FLNK, "$(user):line:b")
#   info(Q:group, {
#       "$(user):circle":{"y": {+channel:"VAL", +trigger:"*"}}
#   })
# }

# record(ai, "$(user):line:b") {
#   field(INP, "$(user):line:a NPP")
#   field(FLNK, "$(user):circle:tick")
#   info(Q:group, {
#       "$(user):line":{"b": {+channel:"VAL", +trigger:"*"}}
#   })
# }

# record(calcout, "$(user):circle:tick") {
#   field(ODLY, "1.0")
#   field(OUT , "$(user):circle:angle.PROC CA") # loop
# }

# EOF

    cat > ${DEST}/dbExample1.db <<"EOF"
record(ai, "$(user):aiExample")
{
        field(DESC, "Analog input")
        field(INP, "$(user):calcExample.VAL  NPP NMS")
        field(EGUF, "10")
        field(EGU, "Counts")
        field(HOPR, "10")
        field(LOPR, "0")
        field(HIHI, "8")
        field(HIGH, "6")
        field(LOW, "4")
        field(LOLO, "2")
        field(HHSV, "MAJOR")
        field(HSV, "MINOR")
        field(LSV, "MINOR")
        field(LLSV, "MAJOR")
}
record(calc, "$(user):calcExample")
{
        field(DESC, "Counter")
        field(SCAN,"1 second")
        field(FLNK, "$(user):aiExample")
        field(CALC, "(A<B)?(A+C):D")
        field(INPA, "$(user):calcExample.VAL  NPP NMS")
        field(INPB, "9")
        field(INPC, "1")
        field(INPD, "0")
        field(EGU, "Counts")
        field(HOPR, "10")
        field(HIHI, "8")
        field(HIGH, "6")
        field(LOW, "4")
        field(LOLO, "2")
        field(HHSV, "MAJOR")
        field(HSV, "MINOR")
        field(LSV, "MINOR")
        field(LLSV, "MAJOR")
}
record(compress,"$(user):compressExample")
{
        field(DESC, "Circular buffer")
        field(INP,"$(user):aiExample.VAL CP NMS")
        field(ALG,"Circular Buffer")
        field(NSAM,"10")
        field(HOPR,"10")
        field(EGU,"Counts")
}

EOF

    cat > ${DEST}/dbExample2.db <<"EOF"
record(calc, "$(user):calcExample$(no)")
{
        alias("$(user):calc$(no)")
        field(DESC, "Counter No. $(no)")
        field(SCAN,"$(scan)")
        field(FLNK, "$(user):aiExample$(no)")
        field(CALC, "(A<B)?(A+C):D")
        field(INPA, "$(user):calcExample$(no).VAL NPP NMS")
        field(INPB, "9")
        field(INPC, "1")
        field(INPD, "0")
        field(EGU, "Counts")
        field(HOPR, "10")
        field(HIHI, "8")
        field(HIGH, "6")
        field(LOW, "4")
        field(LOLO, "2")
        field(HHSV, "MAJOR")
        field(HSV, "MINOR")
        field(LSV, "MINOR")
        field(LLSV, "MAJOR")
}
record(ai, "$(user):aiExample$(no)")
{
        field(DESC, "Analog input No. $(no)")
        field(INP, "$(user):calcExample$(no).VAL NPP NMS")
        field(EGUF, "10")
        field(EGU, "Counts")
        field(HOPR, "10")
        field(LOPR, "0")
        field(HIHI, "8")
        field(HIGH, "6")
        field(LOW, "4")
        field(LOLO, "2")
        field(HHSV, "MAJOR")
        field(HSV, "MINOR")
        field(LSV, "MINOR")
        field(LLSV, "MAJOR")
}
alias("$(user):aiExample$(no)","$(user):ai$(no)")
EOF


    cat > ${DEST}/dbSubExample.db <<"EOF"
record(sub,"$(user):subExample")
{
    field(INAM,"mySubInit")
    field(SNAM,"mySubProcess")
}
record(aSub,"$(user):aSubExample")
{
    field(INAM,"myAsubInit")
    field(SNAM,"myAsubProcess")
    field(FTA,"DOUBLE")
    field(NOA,"10")
    field(INPA,"$(user):compressExample CPP")
}

EOF
}


function add_local_example_makefile
{
    local mod_name=${1}
    ## Module_name.Makefile

    cat > ${mod_name}.Makefile <<EOF
#
#  Copyright (c) 2018 - Present  European Spallation Source ERIC
#
#  The program is free software: you can redistribute
#  it and/or modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation, either version 2 of the
#  License, or any newer version.
#
#  This program is distributed in the hope that it will be useful, but WITHOUT
#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
#  more details.
#
#  You should have received a copy of the GNU General Public License along with
#  this program. If not, see https://www.gnu.org/licenses/gpl-2.0.txt
#
# 
# Author  : Jeong Han Lee
# email   : han.lee@esss.se
# Date    : 
# version : 0.0.1 
#

## The following lines are mandatory, please don't change them.
where_am_I := \$(dir \$(abspath \$(lastword \$(MAKEFILE_LIST))))
include \$(E3_REQUIRE_TOOLS)/driver.makefile
include \$(E3_REQUIRE_CONFIG)/DECOUPLE_FLAGS


ifneq (\$(strip \$(SEQUENCER_DEP_VERSION)),)
sequencer_VERSION=\$(SEQUENCER_DEP_VERSION)
endif

## Exclude linux-ppc64e6500
EXCLUDE_ARCHS = linux-ppc64e6500

APP:=${mod_name}App
APPDB:=\$(APP)/Db
APPSRC:=\$(APP)/src

USR_INCLUDES += -I\$(where_am_I)\$(APPSRC)

TEMPLATES += \$(wildcard \$(APPDB)/*.db)
TEMPLATES += \$(wildcard \$(APPDB)/*.template)

SOURCES += \$(APPSRC)/dbSubExample.c
SOURCES += \$(APPSRC)/myexampleHello.c
SOURCES += \$(APPSRC)/sncExample.stt

DBDS    += \$(APPSRC)/dbSubExample.dbd
DBDS    += \$(APPSRC)/myexampleHello.dbd
DBDS    += \$(APPSRC)/sncExample.dbd


db: 

.PHONY: db 

vlibs:

.PHONY: vlibs


EOF
    
}





function add_module_makefile
{
    local mod_name=${1}
    ## Module_name.Makefile

    cat > ${mod_name}.Makefile <<EOF
#
#  Copyright (c) 2018 - Present  European Spallation Source ERIC
#
#  The program is free software: you can redistribute
#  it and/or modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation, either version 2 of the
#  License, or any newer version.
#
#  This program is distributed in the hope that it will be useful, but WITHOUT
#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
#  more details.
#
#  You should have received a copy of the GNU General Public License along with
#  this program. If not, see https://www.gnu.org/licenses/gpl-2.0.txt
#
# 
# Author  : ${SC_USER}
# email   : ${SC_USER}@esss.se
# Date    : generated by ${SC_LOGDATE}
# version : 0.0.0 
#
# template file is generated by $0 with ${SC_HASH}
# Please look at many other _module_.Makefile in e3-* repository
# 

## The following lines are mandatory, please don't change them.
where_am_I := \$(dir \$(abspath \$(lastword \$(MAKEFILE_LIST))))
include \$(E3_REQUIRE_TOOLS)/driver.makefile
include \$(E3_REQUIRE_CONFIG)/DECOUPLE_FLAGS



# If one would like to use the module dependency restrictly,
# one should look at other modules makefile to add more
# In most case, one should ignore the following lines:

#ifneq (\$(strip \$(ASYN_DEP_VERSION)),)
#asyn_VERSION=\$(ASYN_DEP_VERSION)
#endif

#ifneq (\$(strip \$(SEQUENCER_DEP_VERSION)),)
#sequencer_VERSION=\$(SEQUENCER_DEP_VERSION)
#endif



## Exclude linux-ppc64e6500
##EXCLUDE_ARCHS = linux-ppc64e6500


# APP:=calcApp
# APPDB:=\$(APP)/Db
# APPSRC:=\$(APP)/src


# USR_INCLUDES += -I\$(where_am_I)\$(APPSRC)

# USR_CFLAGS   += -Wno-unused-variable
# USR_CFLAGS   += -Wno-unused-function
# USR_CFLAGS   += -Wno-unused-but-set-variable
# USR_CPPFLAGS += -Wno-unused-variable
# USR_CPPFLAGS += -Wno-unused-function
# USR_CPPFLAGS += -Wno-unused-but-set-variable

# TEMPLATES += \$(wildcard \$(APPDB)/*.db)
# TEMPLATES += \$(wildcard \$(APPDB)/*.db)
# TEMPLATES += \$(wildcard \$(APPDB)/*.proto)
# TEMPLATES += \$(wildcard \$(APPDB)/*.template)


# DBDINC_SRCS += \$(APPSRC)/swaitRecord.c
# DBDINC_SRCS += \$(APPSRC)/sseqRecord.c
# DBDINC_SRCS += \$(APPSRC)/aCalcoutRecord.c
# DBDINC_SRCS += \$(APPSRC)/sCalcoutRecord.c
# DBDINC_SRCS += \$(APPSRC)/transformRecord.c

# DBDINC_DBDS = \$(subst .c,.dbd,   \$(DBDINC_SRCS:\$(APPSRC)/%=%))
# DBDINC_HDRS = \$(subst .c,.h,     \$(DBDINC_SRCS:\$(APPSRC)/%=%))
# DBDINC_DEPS = \$(subst .c,\$(DEP), \$(DBDINC_SRCS:\$(APPSRC)/%=%))


# HEADERS += \$(APPSRC)/sCalcPostfix.h
# HEADERS += \$(APPSRC)/aCalcPostfix.h
# HEADERS += \$(DBDINC_HDRS)


# SOURCES += \$(APPSRC)/sCalcPostfix.c
# SOURCES += \$(APPSRC)/sCalcPerform.c
# SOURCES += \$(APPSRC)/aCalcPostfix.c
# SOURCES += \$(APPSRC)/aCalcPerform.c

# SOURCES += \$(APPSRC)/calcUtil.c
# SOURCES += \$(APPSRC)/myFreeListLib.c
# SOURCES += \$(APPSRC)/devsCalcoutSoft.c
# SOURCES += \$(APPSRC)/devaCalcoutSoft.c
# SOURCES += \$(APPSRC)/subAve.c
# SOURCES += \$(APPSRC)/swaitRecord.c
# SOURCES += \$(APPSRC)/editSseq.st
# SOURCES += \$(APPSRC)/interp.c
# SOURCES += \$(APPSRC)/arrayTest.c
# SOURCES += \$(APPSRC)/aCalcMonitorMem.c
# # DBDINC_SRCS should be last of the series of SOURCES
# SOURCES += \$(DBDINC_SRCS)

# DBDS += \$(APPSRC)/calcSupport_LOCAL.dbd
# DBDS += \$(APPSRC)/calcSupport_withSNCSEQ.dbd
# DBDS += \$(APPSRC)/calcSupport_withSSCAN.dbd

#
# \$(DBDINC_DEPS): \$(DBDINC_HDRS)
#
# .dbd.h:
# 	\$(DBTORECORDTYPEH)  \$(USR_DBDFLAGS) -o \$@ \$<
#
# .PHONY: \$(DBDINC_DEPS) .dbd.h
#
#

# ## xxxRecord.dbd Local Codes 
# DBDINC_SUFF = cpp
# DBDINC_PATH = \$(OPCUASRC)
# DBDINC_SRCS = \$(DBDINC_PATH)/opcuaItemRecord.\$(DBDINC_SUFF)

# ## xxxRecord.dbd Generic Codes : BEGIN
# DBDINC_DBDS = \$(subst .\$(DBDINC_SUFF),.dbd,   \$(DBDINC_SRCS:\$(DBDINC_PATH)/%=%))
# DBDINC_HDRS = \$(subst .\$(DBDINC_SUFF),.h,     \$(DBDINC_SRCS:\$(DBDINC_PATH)/%=%))
# DBDINC_DEPS = \$(subst .\$(DBDINC_SUFF),\$(DEP), \$(DBDINC_SRCS:\$(DBDINC_PATH)/%=%))

# HEADERS += \$(DBDINC_HDRS)
# SOURCES += \$(DBDINC_SRCS)

# \$(DBDINC_DEPS): \$(DBDINC_HDRS)

# .dbd.h:
# 	\$(DBTORECORDTYPEH)  \$(USR_DBDFLAGS) -o \$@ \$<

# .PHONY: \$(DBDINC_DEPS) .dbd.h
# ## Record.dbd Generic codes : END

# The following lines could be useful if one uses the external lib
#
# Examples...
# 
# USR_CFLAGS += -fPIC
# USR_CFLAGS   += -DDEBUG_PRINT
# USR_CPPFLAGS += -DDEBUG_PRINT
# USR_CPPFLAGS += -DUSE_TYPED_RSET
# USR_INCLUDES += -I/usr/include/libusb-1.0
# USR_LDFLAGS += -lusb-1.0
# USR_LDFLAGS += -L /opt/etherlab/lib
# USR_LDFLAGS += -lethercat
# USR_LDFLAGS += -Wl,-rpath=/opt/etherlab/lib

## SYSTEM LIBS 
##
# USR_LIBS += boost_regex
# USR_LIBS += readline
# USR_LIBS += xml2

#

#
# ifeq (\$(T_A),linux-x86_64)
# USR_LDFLAGS += -Wl,--enable-new-dtags
# USR_LDFLAGS += -Wl,-rpath=\$(E3_MODULES_VENDOR_LIBS_LOCATION)
# USR_LDFLAGS += -L\$(E3_MODULES_VENDOR_LIBS_LOCATION)
# USR_LDFLAGS += -lflycapture
# endif

# According to its makefile
# VENDOR_LIBS += \$(SUPPORT)/os/linux-x86_64/libflycapture.so.2.8.3.1
# VENDOR_LIBS += \$(SUPPORT)/os/linux-x86_64/libflycapture.so.2
# VENDOR_LIBS += \$(SUPPORT)/os/linux-x86_64/libflycapture.so



SCRIPTS += \$(wildcard ../iocsh/*.iocsh)


## This RULE should be used in case of inflating DB files 
## db rule is the default in RULES_DB, so add the empty one
## Please look at e3-mrfioc2 for example.

db: 

.PHONY: db 

#
# USR_DBFLAGS += -I . -I ..
# USR_DBFLAGS += -I \$(EPICS_BASE)/db
# USR_DBFLAGS += -I \$(APPDB)
#
# SUBS=\$(wildcard \$(APPDB)/*.substitutions)
# TMPS=\$(wildcard \$(APPDB)/*.template)
#
# db: \$(SUBS) \$(TMPS)

# \$(SUBS):
#	@printf "Inflating database ... %44s >>> %40s \n" "\$@" "\$(basename \$(@)).db"
#	@rm -f  \$(basename \$(@)).db.d  \$(basename \$(@)).db
#	@\$(MSI) -D \$(USR_DBFLAGS) -o \$(basename \$(@)).db -S \$@  > \$(basename \$(@)).db.d
#	@\$(MSI)    \$(USR_DBFLAGS) -o \$(basename \$(@)).db -S \$@

# \$(TMPS):
#	@printf "Inflating database ... %44s >>> %40s \n" "\$@" "\$(basename \$(@)).db"
#	@rm -f  \$(basename \$(@)).db.d  \$(basename \$(@)).db
#	@\$(MSI) -D \$(USR_DBFLAGS) -o \$(basename \$(@)).db \$@  > \$(basename \$(@)).db.d
#	@\$(MSI)    \$(USR_DBFLAGS) -o \$(basename \$(@)).db \$@

#
# .PHONY: db \$(SUBS) \$(TMPS)

vlibs:

.PHONY: vlibs

# vlibs: \$(VENDOR_LIBS)

# \$(VENDOR_LIBS):
# 	\$(QUIET)\$(SUDO) install -m 555 -d \$(E3_MODULES_VENDOR_LIBS_LOCATION)/
# 	\$(QUIET)\$(SUDO) install -m 555 \$@ \$(E3_MODULES_VENDOR_LIBS_LOCATION)/

# .PHONY: \$(VENDOR_LIBS) vlibs



EOF
    
}


function add_patch
{
    cat > README.md <<EOF
# Site Specific EPICS Module Patch Files

## Changes
The changes were tested in local environemnt, and commits to the forked repository and do pull request to the epics community module repository.

* Check the original HASH, and your own master
* feb8856 : The original HASH
* master : Changed


## How to create a p0 patch file between commits


* Show what the difference between commits


* Create p0 patch

\`\`\`
\$git diff feb8856 master --no-prefix > ../patch/Site/E3_MODULE_VERSION-what_ever_filename.p0.patch
\`\`\`

EOF

    cat > HISTORY.md <<EOF
# E3_MODULE_VERSION-what_ever_filename.p0.patch

Generic Description.....

* created by Jeong Han Lee, han.lee@esss.se
* related URL or reference https://github.com/icshwi
* Tuesday, February 13 13:24:57 CET 2018
EOF

}



function add_CONFIG_siteMods
{
    cat > CONFIG <<"EOF"
#
VARS_EXCLUDES := $(.VARIABLES)

ifneq (,$(findstring dev,$(MAKECMDGOALS)))
include $(TOP)/configure/RELEASE_DEV
else
include $(TOP)/configure/RELEASE
endif

ifneq (,$(findstring dev,$(MAKECMDGOALS)))
include $(TOP)/configure/CONFIG_MODULE_DEV
else
include $(TOP)/configure/CONFIG_MODULE
endif

E3_REQUIRE_LOCATION := $(EPICS_BASE)/$(E3_REQUIRE_NAME)/$(E3_REQUIRE_VERSION)
REQUIRE_CONFIG := $(E3_REQUIRE_LOCATION)/configure

include $(REQUIRE_CONFIG)/CONFIG

EOF
}


function add_CONFIG_siteMods_local
{
    cat > CONFIG <<"EOF"
#
VARS_EXCLUDES := $(.VARIABLES)

include $(TOP)/configure/RELEASE
include $(TOP)/configure/CONFIG_MODULE

E3_REQUIRE_LOCATION := $(EPICS_BASE)/$(E3_REQUIRE_NAME)/$(E3_REQUIRE_VERSION)
REQUIRE_CONFIG := $(E3_REQUIRE_LOCATION)/configure

include $(REQUIRE_CONFIG)/CONFIG

EOF
}




function add_CONFIG_siteApps
{
    cat > CONFIG <<"EOF"
#
VARS_EXCLUDES := $(.VARIABLES)

ifneq (,$(findstring dev,$(MAKECMDGOALS)))
include $(TOP)/configure/RELEASE_DEV
else
include $(TOP)/configure/RELEASE
endif

ifneq (,$(findstring dev,$(MAKECMDGOALS)))
include $(TOP)/configure/CONFIG_MODULE_DEV
else
include $(TOP)/configure/CONFIG_MODULE
endif

E3_REQUIRE_LOCATION := $(EPICS_BASE)/$(E3_REQUIRE_NAME)/$(E3_REQUIRE_VERSION)
REQUIRE_CONFIG := $(E3_REQUIRE_LOCATION)/configure
E3_MODULES_PATH := $(E3_REQUIRE_LOCATION)/siteApps

include $(REQUIRE_CONFIG)/CONFIG

EOF
    
}



function add_CONFIG_siteApps_local
{
    cat > CONFIG <<"EOF"
#
VARS_EXCLUDES := $(.VARIABLES)

include $(TOP)/configure/RELEASE
include $(TOP)/configure/CONFIG_MODULE

E3_REQUIRE_LOCATION := $(EPICS_BASE)/$(E3_REQUIRE_NAME)/$(E3_REQUIRE_VERSION)
REQUIRE_CONFIG := $(E3_REQUIRE_LOCATION)/configure
E3_MODULES_PATH := $(E3_REQUIRE_LOCATION)/siteApps

include $(REQUIRE_CONFIG)/CONFIG

EOF
    
}



function add_RELEASE
{
    cat > RELEASE <<EOF
#
EPICS_BASE=${_EPICS_BASE}

E3_REQUIRE_NAME:=${_E3_REQUIRE_NAME}
E3_REQUIRE_VERSION:=${_E3_REQUIRE_VERSION}

# The definitions shown below can also be placed in an untracked RELEASE.local
-include \$(TOP)/../../RELEASE.local
-include \$(TOP)/../RELEASE.local
-include \$(TOP)/configure/RELEASE.local

EOF

}

function add_RELEASE_DEV
{
    cat > RELEASE_DEV <<EOF
#
EPICS_BASE=${_EPICS_BASE}

E3_REQUIRE_NAME:=${_E3_REQUIRE_NAME}
E3_REQUIRE_VERSION:=${_E3_REQUIRE_VERSION}

# The definitions shown below can also be placed in an untracked RELEASE_DEV.local
-include \$(TOP)/../../RELEASE_DEV.local
-include \$(TOP)/../RELEASE_DEV.local
-include \$(TOP)/configure/RELEASE_DEV.local

EOF
    
}


function add_RELEASE_Update
{
    local base_path=$1;shift
    local require_version=$1;shift
    
    cat > RELEASE <<EOF
#
EPICS_BASE=${base_path}

E3_REQUIRE_NAME:=require
E3_REQUIRE_VERSION:=${require_version}

# The definitions shown below can also be placed in an untracked RELEASE.local
-include \$(TOP)/../../RELEASE.local
-include \$(TOP)/../RELEASE.local
-include \$(TOP)/configure/RELEASE.local

EOF

    cat > RELEASE_DEV <<EOF
#
EPICS_BASE=${base_path}

E3_REQUIRE_NAME:=require
E3_REQUIRE_VERSION:=${require_version}

# The definitions shown below can also be placed in an untracked RELEASE_DEV.local
-include \$(TOP)/../../RELEASE_DEV.local
-include \$(TOP)/../RELEASE_DEV.local
-include \$(TOP)/configure/RELEASE_DEV.local

EOF
    
}




function add_CONFIG_MODULE
{

       cat > CONFIG_MODULE <<EOF
#
EPICS_MODULE_NAME:=${_EPICS_MODULE_NAME}

EPICS_MODULE_TAG:=master
#
E3_MODULE_VERSION:=master

# DEPENDENT MODULE VERSION
# For Example, 
#DEVLIB2_DEP_VERSION:=2.9.0
#ASYN_DEP_VERSION:=4.33.0
#PCRE_DEP_VERSION:=8.41.
#ADCORE_DEP_VERSION:=3.3.2
#ADSUPPORT_DEP_VERSION:=1.4.0
#LOKI_DEP_VERSION=1.0.0
#NDS_DEP_VERSION=2.3.3
#SIS8300DRV_DEP_VERSION=4.3.1
#SEQUENCER_DEP_VERSION=2.2.6
#
# 
#E3_KMOD_SRC_PATH:=\$(E3_MODULE_SRC_PATH)
#
# In most case, we don't need to touch the following variables.
#

E3_MODULE_NAME:=\$(EPICS_MODULE_NAME)
E3_MODULE_SRC_PATH:=${_E3_MODULE_SRC_PATH}
E3_MODULE_MAKEFILE:=\$(EPICS_MODULE_NAME).Makefile


-include \$(TOP)/configure/CONFIG_OPTIONS
# The definitions shown below can also be placed in an untracked CONFIG_MODULE.local
-include \$(TOP)/configure/CONFIG_MODULE.local

EOF

}

function add_CONFIG_MODULE_DEV
{

    cat > CONFIG_MODULE_DEV <<EOF
#
EPICS_MODULE_NAME:=${_EPICS_MODULE_NAME}
EPICS_MODULE_TAG:=master
#
E3_MODULE_VERSION:=develop

# DEPENDENT MODULE VERSION
# DEPENDENT MODULE VERSION
# For Example, 
#DEVLIB2_DEP_VERSION:=2.9.0
#ASYN_DEP_VERSION:=4.33.0
#PCRE_DEP_VERSION:=8.41.
#ADCORE_DEP_VERSION:=3.3.2
#ADSUPPORT_DEP_VERSION:=1.4.0
#LOKI_DEP_VERSION=1.0.0
#NDS_DEP_VERSION=2.3.3
#SIS8300DRV_DEP_VERSION=4.3.1
#SEQUENCER_DEP_VERSION=2.2.6
#
#
# 
#E3_KMOD_SRC_PATH:=\$(E3_MODULE_SRC_PATH)
#
# In most case, we don't need to touch the following variables.
#

E3_MODULE_NAME:=\$(EPICS_MODULE_NAME)
E3_MODULE_SRC_PATH:=${_E3_MODULE_SRC_PATH}-dev
E3_MODULE_MAKEFILE:=\$(EPICS_MODULE_NAME).Makefile

#E3_MODULE_DEV_GITURL:="https://where your git repo which you would like to clone"
E3_MODULE_DEV_GITURL:="${_E3_MODULE_GITURL_FULL}"

# The definitions shown below can also be placed in an untracked CONFIG_MODULE_DEV.local
-include \$(TOP)/configure/CONFIG_MODULE_DEV.local

EOF
    
}


function add_RULES_siteMods
{
    cat > RULES <<"EOF"

include $(REQUIRE_CONFIG)/RULES_SITEMODS
#include $(REQUIRE_CONFIG)/RULES_EPICS

include $(TOP)/configure/module/RULES_MODULE
-include $(TOP)/configure/module/RULES_DKMS_L

EOF

}


function add_RULES_siteApps
{
    cat > RULES <<"EOF"

include $(REQUIRE_CONFIG)/RULES_SITEAPPS
#include $(REQUIRE_CONFIG)/RULES_EPICS

include $(TOP)/configure/module/RULES_MODULE
-include $(TOP)/configure/module/RULES_DKMS_L

EOF

}


function add_RULES_siteApps_local
{
    cat > RULES <<"EOF"

include $(REQUIRE_CONFIG)/RULES_E3
include $(REQUIRE_CONFIG)/DEFINES_FT
include $(REQUIRE_CONFIG)/RULES_PATCH
include $(REQUIRE_CONFIG)/RULES_E3_SITEAPPS

include $(REQUIRE_CONFIG)/RULES_VLIBS
include $(REQUIRE_CONFIG)/RULES_VARS

include $(TOP)/configure/module/RULES_MODULE
-include $(TOP)/configure/module/RULES_DKMS_L

EOF
}


function add_CONFIG_OPTIONS
{
    cat > CONFIG_OPTIONS <<"EOF"
#
# WITH_PVA:=NO
#
# The definitions shown below can also be placed in an untracked CONFIG_OPTIONS.local
-include $(TOP)/configure/CONFIG_OPTIONS.local

EOF
}




function add_configure_siteMods
{
    add_CONFIG_siteMods;
    add_RELEASE;
    add_RELEASE_DEV;
    add_CONFIG_MODULE;
    add_CONFIG_MODULE_DEV;
    add_RULES_siteMods;
    add_CONFIG_OPTIONS;
}



function add_configure_siteApps
{
    add_CONFIG_siteApps;
    add_RELEASE;
    add_RELEASE_DEV;
    add_CONFIG_MODULE;
    add_CONFIG_MODULE_DEV;
    add_RULES_siteApps;
    add_CONFIG_OPTIONS;
}


function add_configure_siteApps_local
{
    add_CONFIG_siteApps_local;
    add_RELEASE;
    add_CONFIG_MODULE;
    add_RULES_siteApps_local;
    add_CONFIG_OPTIONS;
}




function add_configure_module
{
    add_rules_module;
    add_rules_dkms_l;
}

function add_rules_module
{
    cat > RULES_MODULE <<"EOF"
#
.PHONY: db hdrs

db: conf
	$(QUIET) $(E3_MODULE_MAKE_CMDS) db

hdrs:
#	$(SUDO) install -m 755 -d $(E3_MODULES_INSTALL_LOCATION_INC)/pv
#	cd $(E3_MODULES_INSTALL_LOCATION_INC) && $(SUDO) mv *.h pv/

#.PHONY: epics
#epics:
#	$(QUIET)echo "EPICS_BASE=$(EPICS_BASE)"        > $(TOP)/$(E3_MODULE_SRC_PATH)/configure/RELEASE
#	$(QUIET)echo "ASYN=$(M_ASYN)"                  > $(TOP)/$(E3_MODULE_SRC_PATH)/configure/RELEASE
#	$(QUIET)echo "SSCAN=$(M_SSCAN)"               >> $(TOP)/$(E3_MODULE_SRC_PATH)/configure/RELEASE
#	$(QUIET)echo "SNCSEQ=$(M_SNCSEQ)"             >> $(TOP)/$(E3_MODULE_SRC_PATH)/configure/RELEASE
#	$(QUIET)echo "CHECK_RELEASE = YES"             > $(TOP)/$(E3_MODULE_SRC_PATH)/configure/CONFIG_SITE
#	$(QUIET)echo "INSTALL_LOCATION=$(M_DEVLIB2)"  >> $(TOP)/$(E3_MODULE_SRC_PATH)/configure/CONFIG_SITE
#	$(SUDOBASH) "$(MAKE) -C $(E3_MODULE_SRC_PATH)"

EOF

}

function add_rules_dkms_l
{
 cat > RULES_DKMS_L <<"EOF"

# KMOD_NAME := mrf

# .PHONY: dkms_add

# dkms_add: conf
#       $(MSI) -M name="$(E3_MODULE_NAME)" -M  version="$(E3_MODULE_VERSION)" -M kmod_name="$(KMOD_NAME)" $(TOP)/dkms/dkms_with_msi.conf.in > $(TOP)/dkms/dkms_with_msi.conf
#       $(QUIET) cat $(TOP)/dkms/dkms_with_msi.conf $(TOP)/dkms/dkms_without_msi.conf > $(TOP)/dkms/dkms.conf
#       $(QUIET) install -m 644 $(TOP)/dkms/dkms.conf  $(E3_KMOD_SRC_PATH)/
#       $(SUDO) install -d /usr/src/$(E3_MODULE_NAME)-$(E3_MODULE_VERSION)
#       $(SUDO) cp -r $(TOP)/$(E3_KMOD_SRC_PATH)/* /usr/src/$(E3_MODULE_NAME)-$(E3_MODULE_VERSION)/
#       $(SUDO) $(DKMS) add $(DKMS_ARGS)


# setup:
#       $(QUIET) $(SUDO2) 'echo KERNEL==\"uio*\", ATTR{name}==\"mrf-pci\", MODE=\"0666\" | tee  /etc/udev/rules.d/99-$(KMOD_NAME).rules'
#       $(QUIET) $(SUDO) /bin/udevadm control --reload-rules
#       $(QUIET) $(SUDO) /bin/udevadm trigger
#       $(QUIET) $(SUDO2) 'echo $(KMOD_NAME) | tee /etc/modules-load.d/$(KMOD_NAME).conf'
#       $(QUIET) $(SUDO) depmod --quick
#       $(QUIET) $(SUDO) modprobe -rv $(KMOD_NAME)
#       $(QUIET) $(SUDO) modprobe -v $(KMOD_NAME)
#       $(QUIET) echo ""
#       $(QUIET) echo ""
#       $(QUIET) echo "It is OK to see \"E3/RULES_DKMS:37: recipe for target 'setup' failed\""
#       $(QUIET) echo "---------------------------------------------------------------------"
#       $(QUIET) -ls -l /dev/uio* 2>/dev/null
#       $(QUIET) echo "---------------------------------------------------------------------"


# setup_clean:
#       $(QUIET) $(SUDO) modprobe -rv $(KMOD_NAME)
#       $(SUDO) rm -f /etc/modules-load.d/$(KMOD_NAME).conf
#       $(SUDO) rm -f /etc/udev/rules.d/99-$(KMOD_NAME).rules


# .PHONY: setup setup_clean

EOF

}


